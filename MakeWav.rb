# SET GLOBAL VARIABLES:
# table size
$TABLE_SIZE = 400
# initialize a wavetable
$waveTable = Array.new($TABLE_SIZE)

# This class is used to create .wav files from scratch, and to fill the files
# with audio signal data generated by wavetable synthesis.
class Wav
	# Initialize Wav object with the following arguments:
	#   filename == A string that is the name of the .wav file being created;
	#               the string must end in '.wav'.
	#   numChannels == An integer (either 1 or 2) that describes if the file
	#                  is mono or stereo (stereo is default).
	#   sampleRate == An integer that determines the number of samples that are
	#                 used to create every second of ouput signal during
	#                 digital-to-analog conversion.  Acceptable values are
	#                 22050, 32000, 44100 (default), or 48000.
	#                 NOTE: Because this is a wavetable synthesis program,
	#                       distortion is inherent.  With a wavetable size of
	#                       400, sampleRate values of 32000 and 48000 contain
	#                       noticably more distortion, while values of 22050
	#                       and 44100 contain almost no distortion.
	#   bitsPerSample == An integer that determines the bit depth of each
	#                    sample.  Acceptable values are 16 (default) and 32.
	def initialize(filename, numChannels=2, sampleRate=44100, bitsPerSample=16)
		# INITIALIZE THE ARGUEMNTS AS VARIABLES:
		@filename, @numChannels, @sampleRate, @bitsPerSample =
			filename, numChannels, sampleRate, bitsPerSample
		# INITIALIZE SOME OTHER INSTANCE VARIABLES:
		# variable for keeping track of file offset (used when writing to file)
		@file_offset = 0
		# an array in which to put each byte
		@byte1, @byte2, @byte3, @byte4 = [], [], [], []
		# a 4-char string for each nibble
		@nibble1, @nibble2, @nibble3, @nibble4 = 'xxxx', 'xxxx', 'xxxx', 'xxxx'
		@nibble5, @nibble6, @nibble7, @nibble8 = 'xxxx', 'xxxx', 'xxxx', 'xxxx'
		# initialize an array for the encoded data, and associated variables
		@dataBlock_array = Array.new()
		@dataBlock_joined = nil
		@samples_per_dataBlock = 0
		# L and R table positions
		@tablePosition_L = 0.0
		@tablePosition_R = 0.0
	end

# ------------------------------------------------------------------------
# |                 METHODS INTENDED FOR INTERNAL USE ONLY:               |
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	# MODE: 'file'
	#    Takes a sample in the form of a 16-bit integer (0 <= X <= 65535) and
	#    writes it to the .wav file as little-endian arranged bytes, as per
	#    the RIFF file specification.
	# MODE: 'dataBlock'
	#    Does the same, but instead of writing the sample to file it adds it
	#    to the 'dataBlock' being constructed.  See compose_new_dataBlock()
	#    below for details about what a dataBlock is.
	# Input parameters are:
	#    int == the integer that will be converted to little-endian binary
	#              and written to file
	#    mode == either 'file' (default) or 'dataBlock'.  Modes are described
	#            above.
	def encode_and_write_int16(int, mode='file')
		# make sure 'byte' arrays are clear
		@byte1.clear
		@byte2.clear
		# convert int argument into binary, put in arrays
		15.downto(8) do |x| @byte1.push(int[x]) end
		7.downto(0) do |x| @byte2.push(int[x]) end

		# split bytes into nibbles
		for i in (0...4)
			@nibble1[i] = (@byte1[i+4]).to_s
		end
		for i in (0...4)
			@nibble2[i] = (@byte1[i]).to_s
		end
		for i in (0...4)
			@nibble3[i] = (@byte2[i+4]).to_s
		end
		for i in (0...4)
			@nibble4[i] = (@byte2[i]).to_s
		end

		# order the nibbles in little-endian fashion, join
		correct_endianness_binary = [@nibble4, @nibble3, @nibble2, @nibble1]

		if mode == 'file'
			# join and pack nibbles
			binary_to_write = [correct_endianness_binary.join].pack("B*")
			# write binary to file with correct offset
			File.write(@filename, binary_to_write, @file_offset)
			# increment offset for next method call
			@file_offset += 2
		elsif mode == 'dataBlock'
			# push string into dataBlock_array
			@dataBlock_array.push(correct_endianness_binary.join)
		end
	end

	# MODE: 'file'
	#    Takes a sample in the form of a 32-bit integer (0 <= X <= 4,294,967,296)
	#    and writes it to the .wav file as little-endian arranged bytes, as per
	#    the RIFF file specification.
	# MODE: 'dataBlock'
	#    Does the same, but instead of writing the sample to file it adds it
	#    to the 'dataBlock' being constructed.  See compose_new_dataBlock()
	#    below for details about what a dataBlock is.
	# Input parameters are:
	#    int == The integer that will be converted to little-endian binary
	#           and written to file/dataBlock.
	#    mode == Either 'file' (default) or 'dataBlock'.  Modes are described
	#            above.
	#    byte_offset == An integer that indicates the byte offset when writing
	#                   data to the .wav file (otherwise it overwrites data at
	#                   the beginning of the file).  Default is $file_offset
	#                   variable.  Other values are only used in the
	#                   finalize_wav_header() method (see below).
	def encode_and_write_int32(int, mode='file', byte_offset=@file_offset)
		# make sure 'byte' arrays are clear
		@byte1.clear
		@byte2.clear
		@byte3.clear
		@byte4.clear
		# convert int argument into binary, put in arrays
		31.downto(24) do |x| @byte1.push(int[x]) end
		23.downto(16) do |x| @byte2.push(int[x]) end
		15.downto(8) do |x| @byte3.push(int[x]) end
		7.downto(0) do |x| @byte4.push(int[x]) end

		# split bytes into nibbles (which are labeled in semi-correct endianness)
		# i.e. nibbles are switched in each byte, but bytes are in same order as
		# before
		for i in (0...4)
			@nibble1[i] = (@byte1[i+4]).to_s
		end
		for i in (0...4)
			@nibble2[i] = (@byte1[i]).to_s
		end
		for i in (0...4)
			@nibble3[i] = (@byte2[i+4]).to_s
		end
		for i in (0...4)
			@nibble4[i] = (@byte2[i]).to_s
		end
		for i in (0...4)
			@nibble5[i] = (@byte3[i+4]).to_s
		end
		for i in (0...4)
			@nibble6[i] = (@byte3[i]).to_s
		end
		for i in (0...4)
			@nibble7[i] = (@byte4[i+4]).to_s
		end
		for i in (0...4)
			@nibble8[i] = (@byte4[i]).to_s
		end

		# order the nibbles in little-endian fashion (reverse order), join
		correct_endianness_binary = [@nibble8, @nibble7, @nibble6, @nibble5,
			@nibble4, @nibble3, @nibble2, @nibble1]
		if mode == 'file'
			# join and pack nibbles
			binary_to_write = [correct_endianness_binary.join].pack("B*")
			# write binary to file with correct offset
			File.write(@filename, binary_to_write, byte_offset)
			# increment offset for next method call
			@file_offset += 4
		elsif mode == 'dataBlock'
			# push string into dataBlock_array
			@dataBlock_array.push(correct_endianness_binary.join)
		end
	end

	# Convert a floating point sample value to a 16-bit integer value
	# and write value to file.  Input parameter is:
	#    float_sample == a floating point number that is the sample value that
	#                    will be converted and written to file/dataBlock
	#    mode == 'file' or 'dataBlock' (passed on to encode_and_write method)
	def convert_and_write_float_sample_16bit(float_sample, mode='file')
		# converts sample to 16-bit integer and calls encode-and-write method
		# positive values have one conversion equation...
		if float_sample >= 0
			int_sample = (float_sample * 32767.to_f).round
			# write rounded value to file
			encode_and_write_int16(int_sample, mode)
		# ...negative values have another
		elsif float_sample < 0
			int_sample = (((float_sample + 1.to_f) * 32767.to_f) +
				32768.to_f).round
			# write rounded value to file
			encode_and_write_int16(int_sample, mode)
		end
	end

	# Convert a floating point sample value to a 32-bit integer value
	# and write value to file.  Input parameter is:
	#    float_sample == a floating point number that is the sample value that
	#                    will be converted and written to file/dataBlock
	#    mode == 'file' or 'dataBlock' (passed on to encode_and_write method)
	def convert_and_write_float_sample_32bit(float_sample, mode='file')
		# converts sample to 32-bit integer and calls encode-and-write method
		# positive values have one conversion equation...
		if float_sample >= 0
			int_sample = (float_sample * 2147483647.to_f).round
			# write rounded value to file
			encode_and_write_int32(int_sample, mode)
		# ...negative values have another
		elsif float_sample < 0
			int_sample = (((float_sample + 1.to_f) * 2147483647.to_f) +
				2147483648.to_f).round
			# write rounded value to file
			encode_and_write_int32(int_sample, mode)
		end
	end

# ------------------------------------------------------------------------
# |                 METHODS INTENDED FOR USE IN 'MAIN':                   |
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	# Every .wav file consists of an RIFF chunk-header (12 bytes), a
	# 'fmt ' subchunk (24 bytes), and a 'data' subchunk that contains
	# (8 bytes of info) + audio data.  THIS METHOD writes the RIFF/.wav
	# header, which is all 44 bytes preceding the audio data.
	def write_wav_header()
		# calculate additional parameters included in the .wav header
		block_align = (@bitsPerSample * @numChannels) / 8
		byte_rate = (@sampleRate * @numChannels * @bitsPerSample) / 8

		# write first 16 bytes to file (always the same)
		# 'xxxx' portion will be modified in finalize_wav_header() method (see below)
		File.write(@filename, 'RIFFxxxxWAVEfmt ', @file_offset)
		@file_offset += 16

		# write the rest of the header, except the 'data' subchunk header
		self.encode_and_write_int32(16) # set Subchunk1Size in header
		self.encode_and_write_int16(1) # set AudioFormat to 1 (PCM) in header
		self.encode_and_write_int16(@numChannels) # set NumChannels in header
		self.encode_and_write_int32(@sampleRate) # set SampleRate in header
		self.encode_and_write_int32(byte_rate) # set ByteRate in header
		self.encode_and_write_int16(block_align) # set block align in header
		self.encode_and_write_int16(@bitsPerSample) # set BitsPerSample in header

		# write 8 byte 'data' subchunk header info
		# 'xxxx' portion will be modified in finalize_wav_header() method (see below)
		File.write(@filename, 'dataxxxx', @file_offset)
		@file_offset += 8
	end

	# EXPLANATION OF DATABLOCK:
	#   Converting each sample to an integer and changing it from big-endian to
	#   little-endian bit order is very inefficient.  In order to speed up the
	#   alogrithm, the waveform in the wavetable is only converted and encoded
	#   once, then that data is saved and written to file repeatedly.  The
	#   converted and encoded waveform is called a 'dataBlock'.
	#
	# This method, given a pitchIncrementer value, creates a new data block
	# for the frequency corresponding to that value.  Input parameter is:
	#    pitchIncrementer == a floating point number used to increment the
	#                        wavetable index, therby adjusting pitch
	def compose_new_dataBlock(pitchIncrementer)
		# clear the 'dataBlock' array
		@dataBlock_array.clear
		# adjust pitchIncrementer to account for sample rate
		adjusted_incrementer = (44100.to_f / @sampleRate.to_f) * pitchIncrementer.to_f
		# determine samples_per_dataBlock, provided that each dataBlock is equal
		# to one waveform period
		if ($TABLE_SIZE.to_f).modulo(adjusted_incrementer) == 0.0
			@samples_per_dataBlock = ($TABLE_SIZE.to_f / adjusted_incrementer).to_i
		else
		    @samples_per_dataBlock = (($TABLE_SIZE.to_f / adjusted_incrementer).truncate)
		end
		# reset table positions to 0.0
		@tablePosition_L = 0.0
		@tablePosition_R = 0.0
		# CREATE THE DATABLOCK:
		for i in (0...@samples_per_dataBlock)
			# given table position values, get sample value from wavetable
			sample_value_L = $waveTable[@tablePosition_L.round]
			sample_value_R = $waveTable[@tablePosition_R.round]
			# write each channel to dataBlock
			if @bitsPerSample == 16
				self.convert_and_write_float_sample_16bit(sample_value_L, mode='dataBlock')
				if @numChannels == 2
					self.convert_and_write_float_sample_16bit(sample_value_R, mode='dataBlock')
				end
			elsif @bitsPerSample == 32
				self.convert_and_write_float_sample_32bit(sample_value_L, mode='dataBlock')
				if @numChannels == 2
					self.convert_and_write_float_sample_32bit(sample_value_R, mode='dataBlock')
				end
			end
			# increment the R and L table positions
			@tablePosition_L += adjusted_incrementer
			@tablePosition_R += adjusted_incrementer
		end
		# join the dataBlock array to form the finished dataBlock
		@dataBlock_joined = nil
		@dataBlock_joined = [@dataBlock_array.join].pack("B*")
	end

	# This method writes the dataBlock to file repeatedly, until (noteduration)
	# seconds of audio signal have been written.  Input parameter is:
	#   noteDuration == number of seconds (integer) of audio signal that will
	#                   be written as the waveform contained in the dataBlock
	def write_dataBlock_to_file(noteDuration)
		# calculate the number of dataBlocks to write to file
		numBlocks_to_write = (noteDuration * @sampleRate /
		    @samples_per_dataBlock)
		# calculate bytes per sample
		if @bitsPerSample == 16
			bytesPerSample = 2
		elsif @bitsPerSample == 32
			bytesPerSample = 4
		end
		# write the dataBlocks to file
		for i in (0..numBlocks_to_write)
			# write binary to file with correct offset
			File.write(@filename, @dataBlock_joined, @file_offset)
			# increment offset for next method call
			@file_offset += @samples_per_dataBlock * @numChannels * bytesPerSample
		end
	end

	# Modify Chunksize and Subchunk2Size parameters of .wav header.
	def finalize_wav_header()
		# these are the byte offsets for the Chunksize and Subchunk2Size
		# parts of the .wav file header
		chunk_size = @file_offset - 8
		subChunk2_size = chunk_size - 36
		# set ChunkSize in header
		encode_and_write_int32(chunk_size, mode='file', byte_offset=4)
		# set Subchunk2Size in header
		encode_and_write_int32(subChunk2_size, mode='file', byte_offset=40)
	end
end

# This class is used to write/rewrite the wavetable with a new waveform.
# More to come...
class WaveTable
	# write a sine wave to the wavetable
	def self.sine()
		for i in (0...$TABLE_SIZE)
			$waveTable[i] = Math.sin((i.to_f/$TABLE_SIZE.to_f) * Math::PI * 2.0)
		end
	end

	# write a pseudo-square wave to the wavetable
	def self.square()
		# check that $TABLE_SIZE is an even number, if not
		if $TABLE_SIZE % 2 != 0
			print "\n\tERROR: $TABLE_SIZE needs to be an even integer to "
			print "make a square wave\n"
			return
		end
		# put a square wave in the wavetable
		for i in (0...$TABLE_SIZE)
			if i < ($TABLE_SIZE / 2)
				$waveTable[i] = 0.15
			else
				$waveTable[i] = -0.15
			end
		end
	end

	# write a custom wave to the wavetable (must write a sine wave first,
	# or a null table will be created)
	def self.custom()
		# initialize the array to hold the amplitudes of the harmonics
		harmonic_amplitudes = Array.new(32, nil)
		command_check = nil
		# print info to terminal
		print "\n\t\t ---- SYNTHESIZE A CUSTOM TIMBRE ----\n\n"
		print "type 'z' and hit RETURN for custom synthesis info\n"
		print "type 's' and hit RETURN to synthesize timbre with current parameters\n"
		print "type 'x' and hit RETURN to abort program\n\n"
		print "Enter amplitude of each harmonic:"
		# loop gets harmonic amplitude info
		for x in (0...32)
			# prompt for harmonic amplitude info
			if x == 0
				print "\n  Fundamental: "
				command_check = STDIN.gets.chomp
			else
				print "  Harmonic #{x}: "
				command_check = STDIN.gets.chomp
			end

			# command is processed
			if command_check == 'z'
				print "\n\nINFO:\n\n"
				print "The 'synthesize custom timbre' function allows you to synthesize a new sound by"
				print "\nsetting the relative amplitude for each harmonic, up to the 31st harmonic."
				print "\nRelative amplitudes are values between 0 and 100.  Enter a value for each"
				print "\nharmonic as you are promted.  A value of 0 means the harmonic is not"
				print "\nincluded in the sound.  When you have entered a value for the highest"
				print "\nharmonic that you want to include, enter 's' (without quotations) to"
				print "\nsynthesize the sound.\n\n", "  LOCAL COMMANDS:\n"
				print "  --------------\n", "    z   --->  Print custom synthesis info\n"
				print "    s   --->  Synthesize waveform\n", "    x   --->  Abort program\n"
				redo
			elsif command_check == 'x'
				puts "PROGRAM ABORTED"
				exit()
			elsif command_check == 's' && x == 0
				print "\n\tERROR: Enter amplitude for one or more frequency\n"
				redo
			elsif command_check == 's'
				x = 32
				break
			elsif command_check.to_i > 100
				print "\n\tERROR: Amplitude needs to be 0<=X<=100\n\n"
				redo
			else
				harmonic_amplitudes[x] = command_check.to_i
			end
		end

		# set up some more variables
		addedAmps_scaling = 0
		added_amplitudes = 0.0
		temp_table = Array.new($TABLE_SIZE, 0.0)

		# Overall amplitude of the synthesized waveform is scaled
		# to avoid an arithmetic overflow.
		for i in (0..32)
			unless harmonic_amplitudes[i] == nil
				addedAmps_scaling += harmonic_amplitudes[i]
			end
		end

		# harmonics are added together, one wavetable index at a time
		for i in (0...$TABLE_SIZE)
			added_amplitudes = 0
			for x in (0..32)
				added_amplitudes += ((harmonic_amplitudes[x].to_f / 100.to_f) *
					$waveTable[((x+1) * i) % $TABLE_SIZE]) /
					(addedAmps_scaling.to_f / 100.to_f)
			end
			# added value is stored in a temporary table
			temp_table[i] = added_amplitudes
		end

		# main wavetable is replaced with temp table
		for i in (0...$TABLE_SIZE)
			$waveTable[i] = temp_table[i]
		end
	end
end

class ProgramInit
	# initiate some variables for command processing purposes
	@command = nil
	@loop_set = true
	# initiate file creation parameters
	@filename, @numChannels, @sampleRate, @bitsPerSample = nil, nil, nil, nil

	def self.prompt_and_process()
		print ">> "
		@command = STDIN.gets.chomp
		if @command == 'z'
			# FILL THIS OUT
			puts "INFO"
			return -1
		elsif @command == 'x'
			puts "PROGRAM ABORTED"
			exit()
		else
			return @command
		end
	end

	def self.initialize_with_user_input()
		# print program info
		puts "\n\t  ---------------------------------------------------"
		puts "\t  |               ---- MAKE WAV ----                |"
		puts "\t  ---------------------------------------------------\n"
		puts "type 'z' and hit RETURN for info"
		puts "type 'x' and hit RETURN to abort program\n"
		# prompt for timbre
		puts "Choose timbre for wavetable:"
		puts "  1) Sine wave"
		puts "  2) Square wave"
		puts "  3) Custom timbre"
		# command processing loop...
		while @loop_set do
			@command = self.prompt_and_process()
			if @command == -1
				next
			else
				@loop_set = false
				if @command.to_i == 1
					puts "Creating sine wave..."
					WaveTable.sine
				elsif @command.to_i == 2
					puts "Creating square wave..."
					WaveTable.square
				elsif @command.to_i == 3
					WaveTable.sine
					WaveTable.custom
				else
					puts "\tERROR: Please enter 1, 2, or 3"
					@loop_set = 1
				end
			end
		end
		# prompt for file name
		puts "What do you want to call the .wav file? (must end with '.wav')"
		# command processing loop...
		@loop_set = true
		while @loop_set do
			@command = self.prompt_and_process()
			if @command == -1
				next
			else
				@filename = @command.to_s
				@loop_set = false
			end
		end
		# prompt for number of channels
		puts "Will #{@filename} be mono or stereo?"
		puts "  1) Mono"
		puts "  2) Stereo"
		# command processing loop...
		@loop_set = true
		while @loop_set do
			@command = self.prompt_and_process()
			if @command == -1
				next
			else
				@loop_set = false
				if @command.to_i == 1 || @command.to_i == 2
					@numChannels = @command.to_i
				else
					puts "\tERROR: Please enter 1 or 2"
					@loop_set = 1
				end
			end
		end
		# prompt for sample rate
		puts "Choose sample rate:"
		puts "  1) 22050 Hz"
		puts "  2) 32000 Hz"
		puts "  3) 44100 Hz"
		puts "  4) 48000 Hz"
		# command processing loop...
		@loop_set = true
		while @loop_set do
			@command = self.prompt_and_process()
			if @command == -1
				next
			else
				@loop_set = false
				if @command.to_i == 1
					@sampleRate = 22050
				elsif @command.to_i == 2
					@sampleRate = 32000
				elsif @command.to_i == 3
					@sampleRate = 44100
				elsif @command.to_i == 4
					@sampleRate = 48000
				else
					puts "\tERROR: Please enter 1, 2, 3, or 4"
					@loop_set = 1
				end
			end
		end
		# prompt for bit depth
		puts "Choose sample bit-depth:"
		puts "  1) 16-bit"
		puts "  2) 32-bit"
		# command processing loop...
		@loop_set = true
		while @loop_set do
			@command = self.prompt_and_process()
			if @command == -1
				next
			else
				@loop_set = false
				if @command.to_i == 1
					@bitsPerSample = 16
				elsif @command.to_i == 2
					@bitsPerSample = 32
				else
					puts "\tERROR: Please enter 1 or 2"
					@loop_set = 1
				end
			end
		end
		# initialize a Wav object with user input
		puts "CREATING #{Dir.pwd()}/#{@filename}  PLEASE WAIT..."
		return Wav.new(@filename, @numChannels, @sampleRate, @bitsPerSample)
	end
end


# ------------------------------------------------------------------------
# |                          -- MAIN --                                  |
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# initialize the program with user input prompts
wave = ProgramInit.initialize_with_user_input
# write the RIFF header info to the file
wave.write_wav_header
# create a one-period block of WAV data, using wavetable, that can be
# repeatedly written to the file (much faster than calculating each sample
# from it's floating point value)
wave.compose_new_dataBlock(2.0)
# repeatedly write the data block to the file until 10 seconds of sound
# is recorded
wave.write_dataBlock_to_file(10)
# adjust the block-size parameters in the RIFF header; .wav file is now complete
wave.finalize_wav_header