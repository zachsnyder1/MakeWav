# SET GLOBAL VARIABLES:
# table size
$TABLE_SIZE = 400
# initialize a wavetable
$waveTable = Array.new($TABLE_SIZE)

# This class is used to create .wav files from scratch, and to fill the files
# with audio signal data generated by wavetable synthesis.
class Wav
	# Initialize Wav object with the following arguments:
	#   filename == A string that is the name of the .wav file being created;
	#               the string must end in '.wav'.
	#   numChannels == An integer (either 1 or 2) that describes if the file
	#                  is mono or stereo (stereo is default).
	#   sampleRate == An integer that determines the number of samples that are
	#                 used to create every second of ouput signal during
	#                 digital-to-analog conversion.  Acceptable values are
	#                 22050, 32000, 44100 (default), or 48000.
	#                 NOTE: Because this is a wavetable synthesis program,
	#                       distortion is inherent.  With a wavetable size of
	#                       400, sampleRate values of 32000 and 48000 contain
	#                       noticably more distortion, while values of 22050
	#                       and 44100 contain almost no distortion.
	#   bitsPerSample == An integer that determines the bit depth of each
	#                    sample.  Acceptable values are 16 (default) and 32.
	def initialize(filename, numChannels=2, sampleRate=44100, bitsPerSample=16)
		# INITIALIZE THE ARGUEMNTS AS VARIABLES:
		@filename, @numChannels, @sampleRate, @bitsPerSample =
			filename, numChannels, sampleRate, bitsPerSample
		# INITIALIZE SOME OTHER INSTANCE VARIABLES:
		# variable for keeping track of file offset (used when writing to file)
		@file_offset = 0
		# an array in which to put each byte
		@byte1, @byte2, @byte3, @byte4 = [], [], [], []
		# a 4-char string for each nibble
		@nibble1, @nibble2, @nibble3, @nibble4 = 'xxxx', 'xxxx', 'xxxx', 'xxxx'
		@nibble5, @nibble6, @nibble7, @nibble8 = 'xxxx', 'xxxx', 'xxxx', 'xxxx'
		# initialize an array for the encoded data, and associated variables
		@dataBlock_array = Array.new()
		@dataBlock_joined = nil
		@samples_per_dataBlock = 0
		# L and R table positions
		@tablePosition_L = 0.0
		@tablePosition_R = 0.0
	end

# ------------------------------------------------------------------------
# |                 METHODS INTENDED FOR INTERNAL USE ONLY:               |
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	# MODE: 'file'
	#    Takes a sample in the form of a 16-bit integer (0 <= X <= 65535) and
	#    writes it to the .wav file as little-endian arranged bytes, as per
	#    the RIFF file specification.
	# MODE: 'dataBlock'
	#    Does the same, but instead of writing the sample to file it adds it
	#    to the 'dataBlock' being constructed.  See compose_new_dataBlock()
	#    below for details about what a dataBlock is.
	# Input parameters are:
	#    int == the integer that will be converted to little-endian binary
	#              and written to file
	#    mode == either 'file' (default) or 'dataBlock'.  Modes are described
	#            above.
	def encode_and_write_int16(int, mode='file')
		# make sure 'byte' arrays are clear
		@byte1.clear
		@byte2.clear
		# convert int argument into binary, put in arrays
		15.downto(8) do |x| @byte1.push(int[x]) end
		7.downto(0) do |x| @byte2.push(int[x]) end

		# split bytes into nibbles
		for i in (0...4)
			@nibble1[i] = (@byte1[i+4]).to_s
		end
		for i in (0...4)
			@nibble2[i] = (@byte1[i]).to_s
		end
		for i in (0...4)
			@nibble3[i] = (@byte2[i+4]).to_s
		end
		for i in (0...4)
			@nibble4[i] = (@byte2[i]).to_s
		end

		# order the nibbles in little-endian fashion, join
		correct_endianness_binary = [@nibble4, @nibble3, @nibble2, @nibble1]

		if mode == 'file'
			# join and pack nibbles
			binary_to_write = [correct_endianness_binary.join].pack("B*")
			# write binary to file with correct offset
			File.write(@filename, binary_to_write, @file_offset)
			# increment offset for next method call
			@file_offset += 2
		elsif mode == 'dataBlock'
			# push string into dataBlock_array
			@dataBlock_array.push(correct_endianness_binary.join)
		end
	end

	# MODE: 'file'
	#    Takes a sample in the form of a 32-bit integer (0 <= X <= 4,294,967,296)
	#    and writes it to the .wav file as little-endian arranged bytes, as per
	#    the RIFF file specification.
	# MODE: 'dataBlock'
	#    Does the same, but instead of writing the sample to file it adds it
	#    to the 'dataBlock' being constructed.  See compose_new_dataBlock()
	#    below for details about what a dataBlock is.
	# Input parameters are:
	#    int == The integer that will be converted to little-endian binary
	#           and written to file/dataBlock.
	#    mode == Either 'file' (default) or 'dataBlock'.  Modes are described
	#            above.
	#    byte_offset == An integer that indicates the byte offset when writing
	#                   data to the .wav file (otherwise it overwrites data at
	#                   the beginning of the file).  Default is $file_offset
	#                   variable.  Other values are only used in the
	#                   finalize_wav_header() method (see below).
	def encode_and_write_int32(int, mode='file', byte_offset=@file_offset)
		# make sure 'byte' arrays are clear
		@byte1.clear
		@byte2.clear
		@byte3.clear
		@byte4.clear
		# convert int argument into binary, put in arrays
		31.downto(24) do |x| @byte1.push(int[x]) end
		23.downto(16) do |x| @byte2.push(int[x]) end
		15.downto(8) do |x| @byte3.push(int[x]) end
		7.downto(0) do |x| @byte4.push(int[x]) end

		# split bytes into nibbles (which are labeled in semi-correct endianness)
		# i.e. nibbles are switched in each byte, but bytes are in same order as
		# before
		for i in (0...4)
			@nibble1[i] = (@byte1[i+4]).to_s
		end
		for i in (0...4)
			@nibble2[i] = (@byte1[i]).to_s
		end
		for i in (0...4)
			@nibble3[i] = (@byte2[i+4]).to_s
		end
		for i in (0...4)
			@nibble4[i] = (@byte2[i]).to_s
		end
		for i in (0...4)
			@nibble5[i] = (@byte3[i+4]).to_s
		end
		for i in (0...4)
			@nibble6[i] = (@byte3[i]).to_s
		end
		for i in (0...4)
			@nibble7[i] = (@byte4[i+4]).to_s
		end
		for i in (0...4)
			@nibble8[i] = (@byte4[i]).to_s
		end

		# order the nibbles in little-endian fashion (reverse order), join
		correct_endianness_binary = [@nibble8, @nibble7, @nibble6, @nibble5,
			@nibble4, @nibble3, @nibble2, @nibble1]
		if mode == 'file'
			# join and pack nibbles
			binary_to_write = [correct_endianness_binary.join].pack("B*")
			# write binary to file with correct offset
			File.write(@filename, binary_to_write, byte_offset)
			# increment offset for next method call
			@file_offset += 4
		elsif mode == 'dataBlock'
			# push string into dataBlock_array
			@dataBlock_array.push(correct_endianness_binary.join)
		end
	end

	# Convert a floating point sample value to a 16-bit integer value
	# and write value to file.  Input parameter is:
	#    float_sample == a floating point number that is the sample value that
	#                    will be converted and written to file/dataBlock
	#    mode == 'file' or 'dataBlock' (passed on to encode_and_write method)
	def convert_and_write_float_sample_16bit(float_sample, mode='file')
		# converts sample to 16-bit integer and calls encode-and-write method
		# positive values have one conversion equation...
		if float_sample >= 0
			int_sample = (float_sample * 32767.to_f).round
			# write rounded value to file
			encode_and_write_int16(int_sample, mode)
		# ...negative values have another
		elsif float_sample < 0
			int_sample = (((float_sample + 1.to_f) * 32767.to_f) +
				32768.to_f).round
			# write rounded value to file
			encode_and_write_int16(int_sample, mode)
		end
	end

	# Convert a floating point sample value to a 32-bit integer value
	# and write value to file.  Input parameter is:
	#    float_sample == a floating point number that is the sample value that
	#                    will be converted and written to file/dataBlock
	#    mode == 'file' or 'dataBlock' (passed on to encode_and_write method)
	def convert_and_write_float_sample_32bit(float_sample, mode='file')
		# converts sample to 32-bit integer and calls encode-and-write method
		# positive values have one conversion equation...
		if float_sample >= 0
			int_sample = (float_sample * 2147483647.to_f).round
			# write rounded value to file
			encode_and_write_int32(int_sample, mode)
		# ...negative values have another
		elsif float_sample < 0
			int_sample = (((float_sample + 1.to_f) * 2147483647.to_f) +
				2147483648.to_f).round
			# write rounded value to file
			encode_and_write_int32(int_sample, mode)
		end
	end

# ------------------------------------------------------------------------
# |                 METHODS INTENDED FOR USE IN 'MAIN':                   |
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	# Every .wav file consists of an RIFF chunk-header (12 bytes), a
	# 'fmt ' subchunk (24 bytes), and a 'data' subchunk that contains
	# (8 bytes of info) + audio data.  THIS METHOD writes the RIFF/.wav
	# header, which is all 44 bytes preceding the audio data.
	def write_wav_header()
		# calculate additional parameters included in the .wav header
		block_align = (@bitsPerSample * @numChannels) / 8
		byte_rate = (@sampleRate * @numChannels * @bitsPerSample) / 8

		# write first 16 bytes to file (always the same)
		# 'xxxx' portion will be modified in finalize_wav_header() method (see below)
		File.write(@filename, 'RIFFxxxxWAVEfmt ', @file_offset)
		@file_offset += 16

		# write the rest of the header, except the 'data' subchunk header
		self.encode_and_write_int32(16) # set Subchunk1Size in header
		self.encode_and_write_int16(1) # set AudioFormat to 1 (PCM) in header
		self.encode_and_write_int16(@numChannels) # set NumChannels in header
		self.encode_and_write_int32(@sampleRate) # set SampleRate in header
		self.encode_and_write_int32(byte_rate) # set ByteRate in header
		self.encode_and_write_int16(block_align) # set block align in header
		self.encode_and_write_int16(@bitsPerSample) # set BitsPerSample in header

		# write 8 byte 'data' subchunk header info
		# 'xxxx' portion will be modified in finalize_wav_header() method (see below)
		File.write(@filename, 'dataxxxx', @file_offset)
		@file_offset += 8
	end

	# EXPLANATION OF DATABLOCK:
	#   Converting each sample to an integer and changing it from big-endian to
	#   little-endian bit order is very inefficient.  In order to speed up the
	#   alogrithm, the waveform in the wavetable is only converted and encoded
	#   once, then that data is saved and written to file repeatedly.  The
	#   converted and encoded waveform is called a 'dataBlock'.
	#
	# This method, given a pitchIncrementer value, creates a new data block
	# for the frequency corresponding to that value.  Input parameter is:
	#    pitchIncrementer == a floating point number used to increment the
	#                        wavetable index, therby adjusting pitch
	def compose_new_dataBlock(pitchIncrementer)
		# clear the 'dataBlock' array
		@dataBlock_array.clear
		# adjust pitchIncrementer to account for sample rate
		adjusted_incrementer = (44100.to_f / @sampleRate.to_f) * pitchIncrementer.to_f
		# determine samples_per_dataBlock, provided that each dataBlock is equal
		# to one waveform period
		if ($TABLE_SIZE.to_f).modulo(adjusted_incrementer) == 0.0
			@samples_per_dataBlock = ($TABLE_SIZE.to_f / adjusted_incrementer).to_i
		else
		    @samples_per_dataBlock = (($TABLE_SIZE.to_f / adjusted_incrementer).truncate) + 1
		end
		# reset table positions to 0.0
		@tablePosition_L = 0.0
		@tablePosition_R = 0.0
		# CREATE THE DATABLOCK:
		for i in (0...@samples_per_dataBlock)
			# given table position values, get sample value from wavetable
			sample_value_L = $waveTable[@tablePosition_L.round]
			sample_value_R = $waveTable[@tablePosition_R.round]
			# write each channel to dataBlock
			if @bitsPerSample == 16
				self.convert_and_write_float_sample_16bit(sample_value_L, mode='dataBlock')
				if @numChannels == 2
					self.convert_and_write_float_sample_16bit(sample_value_R, mode='dataBlock')
				end
			elsif @bitsPerSample == 32
				self.convert_and_write_float_sample_32bit(sample_value_L, mode='dataBlock')
				if @numChannels == 2
					self.convert_and_write_float_sample_32bit(sample_value_R, mode='dataBlock')
				end
			end
			# increment the R and L table positions
			@tablePosition_L += adjusted_incrementer
			@tablePosition_R += adjusted_incrementer
		end
		# join the dataBlock array to form the finished dataBlock
		@dataBlock_joined = nil
		@dataBlock_joined = [@dataBlock_array.join].pack("B*")
	end

	# This method writes the dataBlock to file repeatedly, until (noteduration)
	# seconds of audio signal have been written.  Input parameter is:
	#   noteDuration == number of seconds (integer) of audio signal that will
	#                   be written as the waveform contained in the dataBlock
	def write_dataBlock_to_file(noteDuration)
		# calculate the number of dataBlocks to write to file
		numBlocks_to_write = (noteDuration * @sampleRate /
		    @samples_per_dataBlock)
		# calculate bytes per sample
		if @bitsPerSample == 16
			bytesPerSample = 2
		elsif @bitsPerSample == 32
			bytesPerSample = 4
		end
		# write the dataBlocks to file
		for i in (0..numBlocks_to_write)
			# write binary to file with correct offset
			File.write(@filename, @dataBlock_joined, @file_offset)
			# increment offset for next method call
			@file_offset += @samples_per_dataBlock * @numChannels * bytesPerSample
		end
	end

	# Modify Chunksize and Subchunk2Size parameters of .wav header.
	def finalize_wav_header()
		# these are the byte offsets for the Chunksize and Subchunk2Size
		# parts of the .wav file header
		chunk_size = @file_offset - 8
		subChunk2_size = chunk_size - 36
		# set ChunkSize in header
		encode_and_write_int32(chunk_size, mode='file', byte_offset=4)
		# set Subchunk2Size in header
		encode_and_write_int32(subChunk2_size, mode='file', byte_offset=40)
	end
end

# This class is used to write/rewrite the wavetable with a new waveform.
# More to come...
class WaveTable
	# write a sine wave to the wavetable
	def self.sine()
		for i in (0...$TABLE_SIZE)
			$waveTable[i] = Math.sin((i.to_f/$TABLE_SIZE.to_f) * Math::PI * 2.0)
		end
	end

	# write a custom wave to the wavetable
	def self.custom()
		# I STILL NEED TO WRITE THIS...
	end
end

# ------------------------------------------------------------------------
# |                          -- MAIN --                                  |
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# put a sine wave in the wavetable
WaveTable.sine 
# initialize a .wav file in which to put a sine wave
wave = Wav.new('sine.wav')
# write the RIFF header info to the file
wave.write_wav_header
# create a one-period block of WAV data, using wavetable, that can be
# repeatedly written to the file (much faster than calculating each sample
# from it's floating point value)
wave.compose_new_dataBlock(8.0)
# repeatedly write the data block to the file until 10 seconds of sound
# is recorded
wave.write_dataBlock_to_file(10)
# adjust the block-size parameters in the RIFF header; .wav file is now complete
wave.finalize_wav_header